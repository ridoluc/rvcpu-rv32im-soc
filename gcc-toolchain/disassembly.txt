
program.elf:     file format elf32-littleriscv


Disassembly of section .text:

80000000 <_start>:
.section .text
.global _start

_start:
    # Initialize the stack pointer
    la sp, _stack
80000000:	20000113          	li	sp,512

    # Copy .data from IMEM to DMEM
    la a0, _data_load_start       # Load destination address (start of .data in DMEM)
80000004:	80000517          	auipc	a0,0x80000
80000008:	0c050513          	addi	a0,a0,192 # c4 <_data_load_end>
    la a1, _data_start          # Load source address (start of .data in IMEM)
8000000c:	10000593          	li	a1,256
    la a2, _data_load_end         # Load end address of .data in DMEM
80000010:	80000617          	auipc	a2,0x80000
80000014:	0b460613          	addi	a2,a2,180 # c4 <_data_load_end>

80000018 <copy_data>:
copy_data:
    beq a0, a2, call_main    # If all .data is copied, jump to clear_bss
80000018:	00c50c63          	beq	a0,a2,80000030 <call_main>
    lw t0, 0(a0)             # Load word from source
8000001c:	00052283          	lw	t0,0(a0)
    sw t0, 0(a1)             # Store word to destination
80000020:	0055a023          	sw	t0,0(a1)
    addi a0, a0, 4           # Increment destination pointer
80000024:	00450513          	addi	a0,a0,4
    addi a1, a1, 4           # Increment source pointer
80000028:	00458593          	addi	a1,a1,4
    j copy_data              # Repeat
8000002c:	fedff06f          	j	80000018 <copy_data>

80000030 <call_main>:

    # Call main
call_main:
    call main                # Call the main function
80000030:	008000ef          	jal	80000038 <main>

80000034 <exit>:

    # Infinite loop after main
exit:
80000034:	0000006f          	j	80000034 <exit>

80000038 <main>:
//     }
// }


// Test program to write to UART at address 0x00000040
int main() {
80000038:	fd010113          	addi	sp,sp,-48
8000003c:	02812623          	sw	s0,44(sp)
80000040:	03010413          	addi	s0,sp,48
    volatile int * uart = (int *)0x00000040; // UART base address
80000044:	04000793          	li	a5,64
80000048:	fef42623          	sw	a5,-20(s0)
    volatile int * uart_control = (int *)(uart + 2); // UART control register
8000004c:	fec42783          	lw	a5,-20(s0)
80000050:	00878793          	addi	a5,a5,8
80000054:	fef42423          	sw	a5,-24(s0)
    volatile int * uart_read = (int *)(uart + 1); // UART read register
80000058:	fec42783          	lw	a5,-20(s0)
8000005c:	00478793          	addi	a5,a5,4
80000060:	fef42223          	sw	a5,-28(s0)

    
    int * uart_baud = (int *)(uart + 3); // UART baud rate register
80000064:	fec42783          	lw	a5,-20(s0)
80000068:	00c78793          	addi	a5,a5,12
8000006c:	fef42023          	sw	a5,-32(s0)
    
    // UART BAUD counter set arbitrarily to 100 matching the testbench  
    // For real tests set the BAUD register according to the actual CPU frequency.
    // Example: CPU Freq = 50MHz, Baud rate = 9600
    // UART Baud setting = 50,000,000 / 9,600 = 5208
    *uart_baud = 100;
80000070:	fe042783          	lw	a5,-32(s0)
80000074:	06400713          	li	a4,100
80000078:	00e7a023          	sw	a4,0(a5)
    

    int count_max =0;
8000007c:	fc042e23          	sw	zero,-36(s0)
    int counter = 0;
80000080:	fc042c23          	sw	zero,-40(s0)
        //     *uart = message[i]; // Write character to UART
        //     // delay_1s(); // Delay to ensure UART is ready
        // }

        // RECEIVE CHARACTER AND ECHO BACK
        if(*uart_control & 0x08) { // Check if UART is ready to read
80000084:	fe842783          	lw	a5,-24(s0)
80000088:	0007a783          	lw	a5,0(a5)
8000008c:	0087f793          	andi	a5,a5,8
80000090:	fe078ae3          	beqz	a5,80000084 <main+0x4c>
            char data = *uart_read; // Read data from UART
80000094:	fe442783          	lw	a5,-28(s0)
80000098:	0007a783          	lw	a5,0(a5)
8000009c:	fcf40ba3          	sb	a5,-41(s0)
            while (*uart_control & 0x01); // Wait until UART buffer is not full
800000a0:	00000013          	nop
800000a4:	fe842783          	lw	a5,-24(s0)
800000a8:	0007a783          	lw	a5,0(a5)
800000ac:	0017f793          	andi	a5,a5,1
800000b0:	fe079ae3          	bnez	a5,800000a4 <main+0x6c>
            *uart = data; // Echo the received character back
800000b4:	fd744703          	lbu	a4,-41(s0)
800000b8:	fec42783          	lw	a5,-20(s0)
800000bc:	00e7a023          	sw	a4,0(a5)
        if(*uart_control & 0x08) { // Check if UART is ready to read
800000c0:	fc5ff06f          	j	80000084 <main+0x4c>
