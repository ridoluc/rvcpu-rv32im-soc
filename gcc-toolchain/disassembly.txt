
program.elf:     file format elf32-littleriscv


Disassembly of section .text:

80000000 <_start>:
.section .text
.global _start

_start:
    # Initialize the stack pointer
    la sp, _stack
80000000:	20000113          	li	sp,512

    # Copy .data from IMEM to DMEM
    la a0, _data_load_start       # Load destination address (start of .data in DMEM)
80000004:	80000517          	auipc	a0,0x80000
80000008:	0d050513          	addi	a0,a0,208 # d4 <_data_load_end>
    la a1, _data_start          # Load source address (start of .data in IMEM)
8000000c:	10000593          	li	a1,256
    la a2, _data_load_end         # Load end address of .data in DMEM
80000010:	80000617          	auipc	a2,0x80000
80000014:	0c460613          	addi	a2,a2,196 # d4 <_data_load_end>

80000018 <copy_data>:
copy_data:
    beq a0, a2, call_main    # If all .data is copied, jump to clear_bss
80000018:	00c50c63          	beq	a0,a2,80000030 <call_main>
    lw t0, 0(a0)             # Load word from source
8000001c:	00052283          	lw	t0,0(a0)
    sw t0, 0(a1)             # Store word to destination
80000020:	0055a023          	sw	t0,0(a1)
    addi a0, a0, 4           # Increment destination pointer
80000024:	00450513          	addi	a0,a0,4
    addi a1, a1, 4           # Increment source pointer
80000028:	00458593          	addi	a1,a1,4
    j copy_data              # Repeat
8000002c:	fedff06f          	j	80000018 <copy_data>

80000030 <call_main>:

    # Call main
call_main:
    call main                # Call the main function
80000030:	008000ef          	jal	80000038 <main>

80000034 <exit>:

    # Infinite loop after main
exit:
80000034:	0000006f          	j	80000034 <exit>

80000038 <main>:

//     return 0;
// }


int main(){
80000038:	fd010113          	addi	sp,sp,-48
8000003c:	02812623          	sw	s0,44(sp)
80000040:	03010413          	addi	s0,sp,48

    const int * ext_peripheral = (int *) 0x10000000; // Base address for EXT peripheral
80000044:	100007b7          	lui	a5,0x10000
80000048:	fef42623          	sw	a5,-20(s0)
    int * ext_control_reg = (int *) (ext_peripheral + 0); // Control register at offset 0
8000004c:	fec42783          	lw	a5,-20(s0)
80000050:	fef42423          	sw	a5,-24(s0)
    int * ext_opA = (int *) (ext_peripheral + 1); // Register 1
80000054:	fec42783          	lw	a5,-20(s0)
80000058:	00478793          	addi	a5,a5,4 # 10000004 <_stack+0xffffe04>
8000005c:	fef42223          	sw	a5,-28(s0)
    int * ext_opB = (int *) (ext_peripheral + 2); // Register 2
80000060:	fec42783          	lw	a5,-20(s0)
80000064:	00878793          	addi	a5,a5,8
80000068:	fef42023          	sw	a5,-32(s0)
    volatile int * ext_result = (int *) (ext_peripheral + 3); // Result register at offset 3
8000006c:	fec42783          	lw	a5,-20(s0)
80000070:	00c78793          	addi	a5,a5,12
80000074:	fcf42e23          	sw	a5,-36(s0)

    *ext_opA = 126; // Write to register 1
80000078:	fe442783          	lw	a5,-28(s0)
8000007c:	07e00713          	li	a4,126
80000080:	00e7a023          	sw	a4,0(a5)
    *ext_opB = 76; // Write to register 2
80000084:	fe042783          	lw	a5,-32(s0)
80000088:	04c00713          	li	a4,76
8000008c:	00e7a023          	sw	a4,0(a5)

    // Wait for control bit 0 to be 1
    while ((*ext_control_reg & 0x01) == 0);
80000090:	00000013          	nop
80000094:	fe842783          	lw	a5,-24(s0)
80000098:	0007a783          	lw	a5,0(a5)
8000009c:	0017f793          	andi	a5,a5,1
800000a0:	fe078ae3          	beqz	a5,80000094 <main+0x5c>
    int value = *ext_result; // Read from result register
800000a4:	fdc42783          	lw	a5,-36(s0)
800000a8:	0007a783          	lw	a5,0(a5)
800000ac:	fcf42c23          	sw	a5,-40(s0)

    volatile int * gpio = (int *) 0x00000000; // GPIO base address
800000b0:	fc042a23          	sw	zero,-44(s0)
    *gpio = value; // Write value to GPIO
800000b4:	fd442783          	lw	a5,-44(s0)
800000b8:	fd842703          	lw	a4,-40(s0)
800000bc:	00e7a023          	sw	a4,0(a5)

    return 0;
800000c0:	00000793          	li	a5,0
800000c4:	00078513          	mv	a0,a5
800000c8:	02c12403          	lw	s0,44(sp)
800000cc:	03010113          	addi	sp,sp,48
800000d0:	00008067          	ret
